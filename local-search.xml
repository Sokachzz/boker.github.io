<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>new</title>
    <link href="/boker.github.io/2024/02/01/new/"/>
    <url>/boker.github.io/2024/02/01/new/</url>
    
    <content type="html"><![CDATA[<p><img src="/boker.github.io/boker.github.io/2024/02/01/new/image-20240201164923678.png"></p><p><img src="/boker.github.io/boker.github.io/2024/02/01/new/image-20240201172400462.png" alt="image-20240201172400462"></p><img src="/boker.github.io/boker.github.io/2024/02/01/new/boker.github.io/2024/02/01/new/hexo/blog\source_posts\new\image-20240201164923678.png" alt="image-20240201164923678"><p><a class="fancybox fancybox.image" href="/boker.github.io/boker.github.io/2024/02/01/new/boker.github.io/2024/02/01/new/hexo/blog\source_posts\new\image-20240201164923678.png" itemscope itemtype="http://schema.org/ImageObject" itemprop="url" data-fancybox="default" rel="default" title="image-20240201164923678" data-caption="image-20240201164923678"><img src="/boker.github.io/boker.github.io/2024/02/01/new/boker.github.io/2024/02/01/new/boker.github.io/2024/02/01/new/hexo/blog/source_posts\new\image-20240201164923678.png" alt="image-20240201164923678"></a></p><img src="/boker.github.io/boker.github.io/2024/02/01/new/boker.github.io/2024/02/01/new/image-20240201164923678.png">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/boker.github.io/2022/12/09/python/python_%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/"/>
    <url>/boker.github.io/2022/12/09/python/python_%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h1><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp_string类</title>
    <link href="/boker.github.io/2022/04/10/cpp-string%E7%B1%BB/"/>
    <url>/boker.github.io/2022/04/10/cpp-string%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>可以用来查看string类的使用方法和功能。</p><span id="more"></span><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li><string></string></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>string month=<span class="hljs-string">&quot;March&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;x&#x27;</span>)</span></span>;<span class="hljs-comment">//表示s2有连着8个x</span><br></code></pre></td></tr></table></figure><p>不可以用单个字符初始化，不可以用数字初始化。可以将字符赋值给string对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <br>s = <span class="hljs-string">&#x27;n&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="求string长度"><a href="#求string长度" class="headerlink" title="求string长度"></a>求string长度</h3><ul><li>string.length();</li></ul><h3 id="输入直接到字符串"><a href="#输入直接到字符串" class="headerlink" title="输入直接到字符串"></a>输入直接到字符串</h3><ul><li>string支持流读取运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string stringObject;<br>cin &gt;&gt; stringObject;<br></code></pre></td></tr></table></figure><ul><li><p>string支持getline函数,函数声明：</p><p>1.istream&amp; getline(istream&amp; is, string&amp; str,chardelim)</p><p>2.istream&amp; getline(istream&amp; is, string&amp; str)</p><ul><li>这里的chardelim是截至终止符，默认是回车。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-built_in">getline</span>(cin,s);<br></code></pre></td></tr></table></figure><h3 id="string的赋值"><a href="#string的赋值" class="headerlink" title="string的赋值"></a>string的赋值</h3><ul><li><p>用 = 赋值</p></li><li><p>用assign成员函数复制</p><ul><li>这里的assign函数可以实现部分复制</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;catpig&quot;</span>)</span>,s3</span>;<br>s3.(<span class="hljs-built_in">assign</span>(s1,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>));<br><span class="hljs-comment">//从s1下标为1的字符开始复制3个字符给s3</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="string单个字符访问"><a href="#string单个字符访问" class="headerlink" title="string单个字符访问"></a>string单个字符访问</h3><ul><li>用下标运算符[]访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s2[<span class="hljs-number">5</span>]=s1[<span class="hljs-number">3</span>]=<span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>成员函数at<ul><li>成员函数at会做范围检查，超出范围会抛出out_of_range异常。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs //cpp">string s1(&quot;hello&quot;);<br>for(int i=0;i&lt;s1.length(),i++)<br>    cout&lt;&lt;s1.at(i)&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="string的连接"><a href="#string的连接" class="headerlink" title="string的连接"></a>string的连接</h3><ul><li>用 + 运算符连接字符串</li><li>用 += 运算符连接字符串</li><li>用成员函数append连接字符串<ul><li>可以从下标为x的位置开始，选择s1.size()个字符连接。</li></ul></li></ul><h3 id="比较string-字典序"><a href="#比较string-字典序" class="headerlink" title="比较string(字典序)"></a>比较string(字典序)</h3><ul><li><p>用关系运算符比较string大小，返回值为bool类型</p></li><li><p>用成员函数compare比较string大小</p><ul><li>可以比较两个字符串中间某一段的大小</li></ul></li></ul><h3 id="取得字串"><a href="#取得字串" class="headerlink" title="取得字串"></a>取得字串</h3><ul><li>成员函数 substr()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s2 = s1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//从下标4开始的5个字符</span><br></code></pre></td></tr></table></figure><h3 id="交换字符串"><a href="#交换字符串" class="headerlink" title="交换字符串"></a>交换字符串</h3><ul><li>成员函数 swap()</li></ul><h3 id="找string中的字符-串"><a href="#找string中的字符-串" class="headerlink" title="找string中的字符(串)"></a>找string中的字符(串)</h3><ul><li>成员函数find()<ul><li>在s1中从前向后找”lo”第一次出现的位置，找到返回l所在位置下标。找不到返回string::npos。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>s1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;lo&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>还可以从下标为x的位置查找字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;ll&quot;</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">//从下标为1的地方开始找</span><br></code></pre></td></tr></table></figure><ul><li>成员函数rfind()<ul><li>在s1中从后向前找字符的位置。</li></ul></li><li>成员函数find_first_of()<ul><li>在s1中从前向后找abcd中任何一个字符第一次出现的地方</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s1.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>成员函数find_last_of()<ul><li>在s1中查找abcd中任何一个字符最后一次出现的地方。</li></ul></li><li>成员函数find_first_not_of()<ul><li>s1中不在abcd中的字母第一次出现的地方</li></ul></li><li>成员函数find_last_not_of()<ul><li>s1中不在abcd中的字母最后一次出现的地方</li></ul></li></ul><h3 id="删除string中的字符"><a href="#删除string中的字符" class="headerlink" title="删除string中的字符"></a>删除string中的字符</h3><ul><li>成员函数erase(x)<ul><li>去掉下标x及之后的字符</li></ul></li></ul><h3 id="替换string中的字符"><a href="#替换string中的字符" class="headerlink" title="替换string中的字符"></a>替换string中的字符</h3><ul><li>成员函数replace(n,m,”abcd”)<ul><li>将s1中下标n开始的m个字符换成”abcd”</li></ul></li></ul><h3 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h3><ul><li>成员函数insert()</li></ul><h3 id="转换成char-字符串"><a href="#转换成char-字符串" class="headerlink" title="转换成char*字符串"></a>转换成char*字符串</h3><ul><li>成员函数c_str()<ul><li>返回值为const char*，以’\0’结尾</li></ul></li><li>成员函数data（）<ul><li>返回值为char*</li></ul></li></ul><h3 id="字符串拷贝"><a href="#字符串拷贝" class="headerlink" title="字符串拷贝"></a>字符串拷贝</h3><ul><li>成员函数copy()<ul><li>可以部分拷贝字符串</li></ul></li></ul><h3 id="从string进行输入输出"><a href="#从string进行输入输出" class="headerlink" title="从string进行输入输出"></a>从string进行输入输出</h3><ul><li>字符串流处理</li><li>用istringstram和ostringstram进行字符串上的输入输出</li></ul><p>字符串输入流istringstram</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world 123 3.5 A&quot;</span>)</span></span>;<br><span class="hljs-function">istreamstream <span class="hljs-title">inputString</span><span class="hljs-params">(input)</span></span>;<br>inputString &gt;&gt; string1 &gt;&gt; string2 &gt;&gt; i &gt;&gt; d &gt;&gt; c;<br></code></pre></td></tr></table></figure><p>字符串输出流ostringstram</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">istreamstream outputString;<br>outputString&lt;&lt;<span class="hljs-string">&quot;this &quot;</span> &lt;&lt; a &lt;&lt;<span class="hljs-string">&quot;ok &quot;</span>&lt;&lt; endl;<br>cout &lt;&lt; outputString.<span class="hljs-built_in">str</span>()<span class="hljs-comment">//这里的返回值是string类型</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_I/O流</title>
    <link href="/boker.github.io/2022/04/09/cpp/cpp-I-O%E6%B5%81/"/>
    <url>/boker.github.io/2022/04/09/cpp/cpp-I-O%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>c++_I/O输入输出流相关知识</p><span id="more"></span><h3 id="检验输入合法性"><a href="#检验输入合法性" class="headerlink" title="检验输入合法性"></a>检验输入合法性</h3><ul><li><p>在使用cin将标准输入流输入到自己设定的变量时，可能会因为输入的类型与设定的变量类型不同而产生异常的返回值。</p></li><li><p>例如,假设我们有一个int型的变量x，而你的输入又是一个非整形时，cin&gt;&gt;x和x的值都将直接被赋为0。</p></li><li><p>因此，我们需要检验输入的合法性。这将通过：</p><ul><li>cin.good()</li><li>cin.clear()</li><li>cin.ignore()</li></ul></li><li><p>cin.good()</p><ul><li>cin.good()，原来的值默认为1。如果输入的值与定义的变量类型不同，则输出cin.good()为0。</li><li>所以先用cin.good()检验你的输入类型是否相同</li></ul></li><li><p>cin.clear()</p><ul><li>cin.clear(),用于修复输入流，使得你得输入能重新进行</li></ul></li><li><p>cin.ignore(streamsize num=1, int delim=EOF)</p><ul><li>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）。</li><li>例如cin.ignore(1,’\n’)，跳过一个1个字节，或者遇到回车时结束。</li></ul></li><li><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; x;<br><span class="hljs-keyword">if</span> (!cin.<span class="hljs-built_in">good</span>()) &#123;<br>cin.<span class="hljs-built_in">clear</span>();<br>cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;输入不规范，请输入1-1000的整数&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>![[Pasted image 20230503115334.png]]</p>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_虚函数和多态</title>
    <link href="/boker.github.io/2022/04/07/cpp/cpp-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/boker.github.io/2022/04/07/cpp/cpp-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>c++虚函数和多态的相关知识</p><span id="more"></span><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li><p>定义：有virtual关键字的成员函数</p><ul><li>virtual关键字只用在函数声明时，写函数体的时候不需要</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>因为派生类是从基类中派生而来，所以可以认为派生类就是基类，于是就有了cpp中的两种赋值规则</p><ul><li><p>派生类的指针赋值给基类指针</p></li><li><p>派生类的对象赋值给基类引用</p><p>​    由于上述两种赋值规则的存在，使得c++中有可能出现一个基类指针指向了派生类的对象的情况，这时候如果基类与派生类中有同名的虚函数，就会用到多态这种机制。在这种机制下，如果基类指针（引用）指向的是基类的对象，那么调用的就是基类的虚函数，如果基类指针（引用）指向的是派生类的对象，那么调用的就是派生类的虚函数。</p></li></ul><h4 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h4><p>多态的存在，有效的增强了程序的可扩充性，减少了增加和修改功能时所需要的代码改动，下面举一个例子解释。</p><ul><li><p>假设有一个怪物对战游戏，其中怪物的种类有dragon，phonix，soldier,wolf等，并且这些怪物可以实现attack（攻击），hurted（受伤），fightback（反击）等功能。</p></li><li><p>普通的实现方式是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dragon</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(phonix* P)</span></span>&#123;<br>P-&gt;<span class="hljs-built_in">hurted</span>(power);<br>        P-&gt;<span class="hljs-built_in">fightback</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//余下的函数，函数体与上面的函数类似</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(soldier* P)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(wolf* P)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fightback</span><span class="hljs-params">(phonix* P)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fightback</span><span class="hljs-params">(soldier* P)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fightback</span><span class="hljs-params">(wolf* P)</span></span>;<br>&#125;<br><span class="hljs-comment">//余下的三种怪物类似，都会有三个仅参数不相同的attack、fightback函数</span><br></code></pre></td></tr></table></figure><ul><li>这时候如果我们需要新增一个怪物类ghost，我们将会需要在先前的每个类中增加一个攻击和反击ghost的函数。</li></ul></li><li><p>多态的实现方式是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">creature</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(creature* P)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fightback</span><span class="hljs-params">(creature* P)</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dragon</span>:<span class="hljs-keyword">public</span> creature&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">(creature* P)</span></span>&#123;<br>        P-&gt;<span class="hljs-built_in">hurted</span>(power);<br>        P-&gt;<span class="hljs-built_in">fightback</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fightback</span><span class="hljs-params">(creature* P)</span></span>;<br>&#125;<br><span class="hljs-comment">//余下的三种怪物类似</span><br></code></pre></td></tr></table></figure><ul><li>通过这种方式，不仅每个类中的同名函数只有一个了，同时，当你需要扩展时，只需要添加一个ghost类，而不需要在先前类中修改任何代码。说一说这样做是如何实现我们需要的功能的，</li></ul></li><li><p>说一说这样做是如何实现我们需要的功能的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dragon Dra;<br>wolf Wo;<br>creature* Cp1 = &amp;Dra;<br>creature* Cp2 = &amp;Wo;<br>Cp1-&gt;<span class="hljs-built_in">attack</span>(Cp2)<br></code></pre></td></tr></table></figure><ul><li><p>首先，建立一个基类指针并且让他指向派生类的对象</p></li><li><p>然后调用cp1指向的攻击函数，由于cp1是一个基类指针并且指向的是派生类dragon类的对象，所以他会调用dragon类的虚函数attack，这样就实现了dragon对象的攻击功能。</p></li><li><p>attack函数传入的参数也是一个基类指针，前面说的类似，同样会调用被指派生类对象的虚函数。</p></li></ul></li></ul><p>综上，多态机制极大的增加了程序的可扩充性，并且简化了你的程序。</p><h4 id="多态的一些使用技巧"><a href="#多态的一些使用技巧" class="headerlink" title="多态的一些使用技巧"></a>多态的一些使用技巧</h4><ul><li>用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作</li><li>在构造函数和析构函数中调用虚函数不是多态，因为这在编译的时候就可以知道调用的使谁的函数。</li><li>当基类中已有virtual函数时，派生类中的同名函数声明与否都会默认是虚函数。</li><li>构造函数不能时虚函数</li></ul><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><ul><li><p>通过基类的指针删除派生类对象的时候，通常情况下只调用基类的析构函数，这样析构就会不完整，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandson</span>:<span class="hljs-keyword">public</span> son&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>son* pson;<br>    pson = <span class="hljs-keyword">new</span> <span class="hljs-built_in">grandson</span>();<br>    <span class="hljs-keyword">delete</span> pson;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序不会调用grandson的析构函数。</p></li><li><p>解决办法</p><ul><li>将基类的析构函数声明为virtual（这样派生类的析构函数会默认为virtual），析构时就会首先调用派生类的析构函数。</li></ul></li><li><p>一般来说，一个类如果定义了虚函数，那么他的析构函数应当定义成虚函数。一个类如果要作为基类，那么析构函数也应当定义成虚函数。</p></li></ul><h4 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h4><ul><li>每个有虚函数的类中的任何一个对象都存放着一个指向虚函数表的指针。</li></ul><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><ul><li><p>纯虚函数：没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>抽象类：包含纯虚函数的类叫抽象类</p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象。</li><li>抽象类的构造函数或析构函数中不能调用纯虚函数</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_类和对象</title>
    <link href="/boker.github.io/2022/04/07/cpp/cpp-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/boker.github.io/2022/04/07/cpp/cpp-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>c++类和对象相关内容</p><span id="more"></span><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>如果使用iostream，就需要使用名称空间编译指令<code>using namespace std</code>，这是因为：</p><p>可能会出现这样一种情况，即两个封装好的产品中都包含相同名称的函数，这样在调用时函数时，编译器将不知道用哪个产品，所以厂商们将函数封装在不同的名称空间中，使用名称空间的名称就可以指出想使用的函数</p><p>例如，microflop和piscine厂商都有名为wanda（）的函数，那么他们调用时的写法应该分别为</p><ul><li>microflop::wanda();</li><li>piscine::wanda();</li></ul><h2 id="使用cout进行输出"><a href="#使用cout进行输出" class="headerlink" title="使用cout进行输出"></a>使用cout进行输出</h2><p><code>cout &lt;&lt; string;</code></p><p><code>cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</code></p><p>cout进行输出的好处在于，使用者不需要说明你输出的变量是什么类型的变量，而是直接通过重载符号输出，可以看做是将后面的变量丢入cout中进行输出</p><ul><li>需要说明的是，cout在打印其他类型变量的时候会将其转换成字符串形式</li></ul><h2 id="使用cin进行输出"><a href="#使用cin进行输出" class="headerlink" title="使用cin进行输出"></a>使用cin进行输出</h2><p><code>cin &gt;&gt; carrots;</code></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="引用头文件"><a href="#引用头文件" class="headerlink" title="引用头文件"></a>引用头文件</h3><ul><li>引用标准库头文件用&lt;&gt;<code>#include&lt;iostream&gt;</code></li><li>引用自己写的头文件用””<code>#include&quot;complex.h&quot;</code></li></ul><h3 id="头文件的标准写法"><a href="#头文件的标准写法" class="headerlink" title="头文件的标准写法"></a>头文件的标准写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">ifndef</span> __COMPLEX__</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> __COMPLEX__</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    这中间是头文件中的内容<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>这是一种防卫式的声明，即如果没有定义过，那么完成定义</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>目前所看到的只使用在类的使用中，即如果在使用类时发现，可能在不同的使用环境下需要使用不同的数据类型，例如，有时候类中使用的参数是int类型，有时是double类型，但是其他部分的代码完全相同，就可以通过使用模板的方法来解决这一问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-comment">//这句话表示，将使用一个类型名为T的变量作为模板</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>)<br>            :<span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)<br>        &#123;&#125;<br>        complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);<br>        <span class="hljs-function">T <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>        <span class="hljs-function">T <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        T re, im;<br>        <span class="hljs-keyword">friend</span> complex&amp; __doap1(complex*, <span class="hljs-type">const</span> complex&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类规范"><a href="#类规范" class="headerlink" title="类规范"></a>类规范</h2><ul><li>类声明<ul><li>以数据成员的方式描述数据部分</li><li>以成员函数的方式描述公有接口</li></ul></li><li>类方法定义<ul><li>描述如何实现类成员函数</li></ul></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>类的对象是该类的某一特定实体（实例），即类类型的变量</li><li>声明形式：类名  对象名；</li></ul><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul><li>private 私有成员<ul><li>只允许本类中的函数访问，包括派生类在内的任何类外部函数都无法访问</li></ul></li><li>public 公有成员（外部接口）<ul><li>使用类对象的程序都可以直接访问公有部分，而对象的私有成员只能通过公有成员函数访问。</li></ul></li><li>protected  保护型成员<ul><li>只允许本类和派生类的成员（函数）访问</li></ul></li></ul><h2 id="成员数据"><a href="#成员数据" class="headerlink" title="成员数据"></a>成员数据</h2><ul><li>放在类的声明体中</li><li>一般情况下，类的数据成员应该声明为私有成员，作为该类的基本属性</li></ul><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ul><li><p>函数声明：在类声明中说明成员函数原型</p></li><li><p>函数实现：</p><ul><li><p>可以在类声明的外面给出函数体实现，但需要在函数名前使用类名加以限定</p><p><code>返回类型 类名::函数名（形参表）&#123;&#125;</code></p></li><li><p>可以直接在类声明中给出函数体，形成内联成员函数</p></li></ul></li><li><p>允许声明重载函数和带默认参数值的函数</p></li></ul><h2 id="类的内联函数"><a href="#类的内联函数" class="headerlink" title="类的内联函数"></a>类的内联函数</h2><ul><li>如果函数在class body内定义完成，便自动成为inline函数的候选人</li><li>是否能成为inline函数取决于函数的复杂程度</li></ul><h2 id="类成员的访问方式"><a href="#类成员的访问方式" class="headerlink" title="类成员的访问方式"></a>类成员的访问方式</h2><ul><li>类中成员互访<ul><li>直接使用成员名</li></ul></li><li>类外访问<ul><li>对象名.成员名的方式访问public属性的成员</li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>创建对象时会自动调用构造函数</li><li>构造函数的名称一定要与类的名称相同</li><li>构造函数的参数可以有默认值，并且由于构造函数的目的是创建对象，它是没有返回值的</li><li>构造函数可以直接访问类的所有数据成员</li><li>允许构造函数带缺省参数（默认值参数），常用来将对象的数据初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span> (<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>        :<span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)<br>    &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>既可以在括号中通过赋值给private数据赋值，也可以通过上述方法初始化数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span> (<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>    &#123; re = r; im = i; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用第一个方法初始化更正规，第一个方法叫做初始化，第二个方法叫赋值</li><li>初始化具有更高的效率</li></ul><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><ul><li>可以有多个构造函数，通过函数重载的方式，初值的设定不同，调用的构造函数就不同</li></ul><h3 id="构造函数使用的限定"><a href="#构造函数使用的限定" class="headerlink" title="构造函数使用的限定"></a>构造函数使用的限定</h3><ul><li>不能被继承</li><li>不能说明为虚函数</li><li>不能显示地调用构造函数</li><li>不能取一个构造函数地址</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>完成对象被删除前的一些清理工作</li><li>在对象的生存期结束的时刻系统自动调用，并释放此对象所属空间</li><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数</li><li>基类析构函数不能被派生类继承</li><li>析构函数没有参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy);<br>    ~<span class="hljs-built_in">Point</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">char</span>* buffer;<br>&#125;;<br>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx,<span class="hljs-type">int</span> yy)<br>&#123;<br>    x=xx; y=yy;<br>    buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(<span class="hljs-number">64</span>);<span class="hljs-comment">//初始化分配一段缓冲内存</span><br>&#125;<br>Point::~<span class="hljs-built_in">Point</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span>(buffer != null)<br>        <span class="hljs-keyword">delete</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><ul><li>拷贝构造函数功能<ul><li>用一个已经存在的对象，去初始化同类的一个新对象</li></ul></li><li>拷贝构造函数声明格式<ul><li>类名（类名&amp;对象名）</li></ul></li><li>拷贝构造函数实现格式<ul><li>类名::类名(类名&amp;对象名){函数体}</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Class <span class="hljs-title">Point</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy);<br>    <span class="hljs-built_in">Point</span>(Point &amp;p);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> x;&#125;;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x,y;<br>&#125;<br>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy)<br>&#123;<br>  x = xx;<br>  y = yy;<br>&#125;<br>Point::<span class="hljs-built_in">Point</span>(Point &amp;p)<br>&#123;<br>  x = p.x;<br>  t = p.y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数的应用"><a href="#拷贝构造函数的应用" class="headerlink" title="拷贝构造函数的应用"></a>拷贝构造函数的应用</h3><ul><li>用类的一个对象初始化该类的另一个对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Point <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-function">Point <span class="hljs-title">B</span><span class="hljs-params">(A)</span></span>;<br>  <span class="hljs-comment">//将A拷贝给B对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数的形参定义为类的对象，调用函数时用于形参与实参的结合<ul><li>仅拷贝，不改变原对象</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point p)</span></span><br><span class="hljs-function"></span>&#123; cout&lt;&lt;p.<span class="hljs-built_in">getX</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Point <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-built_in">f</span>(A);  <span class="hljs-comment">//A拷贝给f的实参</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数的返回值为类的对象，函数完成返回值拷贝到临时对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Point <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br> <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Point A;<br>    A=<span class="hljs-built_in">g</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合类的构造与析构"><a href="#组合类的构造与析构" class="headerlink" title="组合类的构造与析构"></a>组合类的构造与析构</h2><ul><li>类声名后可以作为一个新的数据类型看待，所以可用于其他类的定义，称为类的组合或者是聚合</li><li>类内嵌其他类的对象作为自己的成员</li><li>组合类的构造函数<ul><li>既要初始化本类的基本类型的成员，有要对内嵌对象的成员初始化</li><li>首先调用各个内前对象的初始化列表和构造函数（按内嵌对象在类申明中出现次序），再执行本类的构造函数<br><code>类名::类名（形参表）:内嵌对象1（形参表），内嵌对象2（形参表）</code></li></ul></li><li>组合类的析构函数的调用执行顺序与构造函数相反</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">point</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rect</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    point m_lefttop;<br>    point m_rightbottom;<br>    <span class="hljs-type">int</span> color;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rect</span>(point p1, point p2, <span class="hljs-type">int</span> c);<br>&#125;<br>Rect::<span class="hljs-built_in">Rect</span>(point p1, point p2, <span class="hljs-type">int</span> c)<br>    :<span class="hljs-built_in">m_leftTop</span>(p1),<span class="hljs-built_in">m_rightbottom</span>(p2)<br>&#123;color = c;&#125;;<br></code></pre></td></tr></table></figure><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul><li><p>数组不仅可以由简单变量组成，也可以由对象组成</p><p><code>类名 数组名[对象个数]</code></p></li><li><p>对象数组，有多少个元素，就要调用多少次构造函数</p></li><li><p>如果构造函数只有一个参数，定义数组时可以在等号后面的花括号提供实参</p></li></ul><p><code>Student stu[3] = &#123;20,30,40&#125;</code></p><ul><li>构造函数有多个参数时，只能单个调用构造函数</li></ul><h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><ul><li>存放对象地址的变量，可以访问到所指对象的所有公有成员</li><li>声明方式：<code>类名* 对象指针名</code></li><li>使用方式：<code>对象指针名-&gt;成员名</code></li><li>初始化: 对象指针在使用前，一定要先进行初始化，指向一个已经声明过的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">point* p= &amp;a;<span class="hljs-comment">//a是point的一个对象</span><br><span class="hljs-type">int</span> x=p-&gt;<span class="hljs-built_in">getX</span>();<br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ul><li>this指针隐含于类的成员函数中，指向正在被成员函数操作的对象</li><li>系统调用某个对象的成员函数时，先将该对象的地址赋予this指针，然后调用成员函数</li><li>成员函数通过隐含的使用this指针来访问该对象的其他成员</li><li>通常不能被显示地声明，也不直接用this来引用对象的成员</li></ul><h2 id="类中函数的重载"><a href="#类中函数的重载" class="headerlink" title="类中函数的重载"></a>类中函数的重载</h2><ul><li>类中也可以构造多个同名的普通函数,下面的两个同名函数，由于调用的变量类型不同，被cpp编译器认为是两个函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123;re = r;&#125;<br></code></pre></td></tr></table></figure><ul><li>但是当两个同名函数的调用形式相同时，这两个同名函数不可同时存在</li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>友元是c++提供的一种破坏数据封装和数据隐藏的机制</li><li>通过将一个模块B声明为另一个模块A的友元，模块B能够引用到模块A中本是被隐藏的信息</li><li>可以使用友元函数和友元类</li><li>为了确保数据的完整性，以及数据封装与隐藏的原则，尽量不要使用友元</li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul><li>模块A为类，模块B为函数</li><li>友元函数B是在A声明中由关键字friend修饰说明的非成员函数，在B的函数体中能够通过对象名访问类A的private和protect成员</li><li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择</li><li>访问对象中的成员必须通过对象名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">point</span>(<span class="hljs-type">int</span> xx=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> yy=<span class="hljs-number">0</span>)&#123;x=xx;y=yy;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> X;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> Y;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x,y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(point&amp; a,point&amp; b)</span></span>&#123;<br>    <span class="hljs-type">double</span> dx=a.x-b.x;<br>    <span class="hljs-type">double</span> dy=a.y-b.y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(dx*dx+dy*dy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">5.0</span>)</span>,<span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>)</span></span>;<br>    <span class="hljs-type">double</span> d=<span class="hljs-built_in">distance</span>(p1,p2)<br>    cout&lt;&lt;d&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ul><li>A、B都是类</li><li>若一个类B为另一个类A的友元，则B类的所有成员都能访问对方类A的私有和保护成员</li><li>声明语法：将友元类名在另一个类中使用friend修饰说明</li><li>友元关系是单向的<ul><li>如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据</li><li>但A类不能访问B类的私有和保护数据</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;x&lt;&lt;endl; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>pubilc:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    A a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::set</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    a.x=i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="friend（友元）"><a href="#friend（友元）" class="headerlink" title="friend（友元）"></a>friend（友元）</h2><ul><li>friend可以自由取得private成员</li><li>也可以通过调用公有的函数来取得privata成员，但是由于那是调用函数的操作，所以效率会低</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这个友元函数是在complex class内部定义的</span><br><span class="hljs-keyword">inline</span> complex&amp; __doap1(complex* <span class="hljs-keyword">this</span>, <span class="hljs-type">const</span> complex&amp; r)<br>&#123;<br>    ths-&gt;re += r.re;<br>    ths-&gt;im += r.im;<br>    <span class="hljs-keyword">return</span> *ths;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>相同class的各个object互为friends</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span> (<span class="hljs-type">double</span> r =<span class="hljs-number">0</span> , <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>)<br>        : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>    &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&amp; param)</span></span>&#123; <span class="hljs-keyword">return</span> param.re + param.im; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br>&#125;;<br><span class="hljs-type">int</span> main&#123;<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>    complex c2;<br>    c2.<span class="hljs-built_in">func</span>(c1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><ul><li>new/delete的目的<ul><li>动态分配内存到堆区中，直到他被delete显示地摧毁</li><li>new/delete一定要匹配使用</li></ul></li><li>new：<ul><li>分配内存，调用对象构造函数进行对象初始化</li><li>创建数组：new 类型名[下标表达式]</li><li>new 类型名(初值列表)</li></ul></li><li>delete：<ul><li>调用对象析构函数进行对象销毁，释放对象内存</li><li>删除整个数组：delete[] 数组指针变量</li><li>delete 指针名</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">example</span><span class="hljs-params">()</span></span>&#123;<br>    Table* p1 = <span class="hljs-keyword">new</span> Table;<br>    <span class="hljs-keyword">delete</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h2><ul><li>类中不会改变数据内容的函数，需要加上const</li><li>所以设定类中的数据的时候，应当先考虑这个数据是否需要改变</li><li>如果类中设计时没加const，而调用时用了const，会出现编译错误<br><code>double real () const &#123;return re;&#125;</code></li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>传递者无需知道接受者是以reference形式接收</p><ul><li>pass by value 按值传递</li><li>pass by reference(to const) 引用传递<ul><li>引用传递的底层逻辑就是传指针</li><li>尽量不要传value，传引用会有更高的效率</li></ul></li></ul><p>如果使用者想要得到的效果是，通过传递参数，可以在函数内部改变外部的这个参数的值，那么就可以直接通过传引用来实现。但是如果引用传递的目的仅仅是因为想要提高效率，那么更应当使用const+引用</p><p><code>complex&amp; operator += (const complex&amp;);</code></p><h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><ul><li>return by value</li><li>return by reference(to const)<ul><li>返回值的传递也尽量by reference</li></ul></li><li>不可以通过传引用作为返回值的情况<ul><li>被引用的对象是在函数内部创建的local变量，在函数结束时会消失，这样被引用的对象消失了，这个引用的操作就是错误的</li></ul></li></ul><h2 id="静态数据成员-static"><a href="#静态数据成员-static" class="headerlink" title="静态数据成员 -static"></a>静态数据成员 -static</h2><ul><li>性质：<ul><li>被该类所有对象共享，不属于任何一个具体的对象</li><li>只有一个静态数据存储空间</li><li>存储空间不由构造函数分配，在类外进行定义和初始化</li></ul></li><li>被访问的方式<ul><li>在类外只能访问共有的静态数据成员，访问方式为：<code>类名::静态共有数据成员</code></li><li>类内的非静态成员函数可直接访问static静态数据成员，但要使用非内联函数定义，该函数定义应与静态成员初始化在同一个源程序文件</li></ul></li><li>静态数据初始化一般不在构造函数中进行，而在类定义之外进行，并要用类名来引用<ul><li>初始化方式为：<code>类型 类名::静态数据成员名=初始值</code></li></ul></li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>定义：<ul><li>被说明为static的成员函数，由一个类的所有对象共享</li></ul></li><li>引入的目的：<ul><li>访问同一类中的静态数据成员，维护对象之间共享的数据</li></ul></li><li>被调用的方式<ul><li>在类外调用：<code>类名（对象名）::静态公有成员函数名（实参表）</code></li><li>在类内调用：直接调用静态成员函数</li></ul></li><li>静态成员函数访问本类成员的权限<ul><li>可以直接访问该类的静态数据和函数成员</li><li>访问非静态数据成员，必须通过参数传递方式得到对象名，再通过对象名来访问</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_基础内容</title>
    <link href="/boker.github.io/2022/04/07/cpp/cpp-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/boker.github.io/2022/04/07/cpp/cpp-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>c++相关基础内容</p><span id="more"></span><h1 id="c-基础知识"><a href="#c-基础知识" class="headerlink" title="c++基础知识"></a>c++基础知识</h1><h2 id="visual-stdio的一些用法"><a href="#visual-stdio的一些用法" class="headerlink" title="visual stdio的一些用法"></a>visual stdio的一些用法</h2><ul><li>ctrl+f7单独编译文件</li><li>f5开始调试</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基础数据类型与c语言一致，有一个新增的wchat_t代表宽字符型</p><h3 id="常量const"><a href="#常量const" class="headerlink" title="常量const"></a>常量const</h3><p>常量在程序中不可以改变，可以是任意基础数据类型，常量有两种写法</p><ul><li>#define PI 3.14</li><li>const float PI 3.14<ul><li>二者的区别在于，const需要编译器进行类型检查</li><li>在函数的参数定义中，可以使用const修饰参数，这样在函数内部无法修改参数值</li></ul></li></ul><h2 id="变量存储区"><a href="#变量存储区" class="headerlink" title="变量存储区"></a>变量存储区</h2><ul><li>栈：局部变量，函数参数等，编译器需要时分配，不需要时释放</li><li>堆：由new分配的内存块，他们的释放需要通过delete</li><li>自由存储区： 由malloc分配的内存块，与堆区类似，通过free释放</li><li>静态存储区： 存放静态变量和全局变量</li><li>常量存储区： 存放不能修改的常量，例如字符串常量和数字常量</li></ul><h2 id="变量命名建议"><a href="#变量命名建议" class="headerlink" title="变量命名建议"></a>变量命名建议</h2><ul><li>对于全局变量，最好在变量名前加g_,例如g_maxSize</li><li>类成员可在变量名前加m_.</li></ul><h2 id="基本控制结构"><a href="#基本控制结构" class="headerlink" title="基本控制结构"></a>基本控制结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><ul><li>if-else语句</li><li>switch case语句<ul><li>需要注意的是，csae语句的结尾不要忘了加break，并且不要忘记default分支</li><li>如果一定要省略default，那么应当加注释//no default body</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(xxx)<br>&#123;<br>    case1:&#123;......&#125;;<span class="hljs-keyword">break</span>;<br>    case2:&#123;......&#125;;<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:&#123;......&#125;;<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li>如果条件与循环无关，应当放到外面，使cpu可以流水作业</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><h3 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h3><ul><li>在函数实体前加inline关键字，例如<code>inline int func_1(int a)</code></li><li>在编译时，调用func_1的地方会直接用函数体替换，不会发生控制转移减少参数传递等开销</li><li>这是一种以空间换时间的手段，所以内联函数不应该太长，且不应该出现循环以及switch case</li></ul><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><ul><li>在c++语言中，允许在函数的说明或者定义时给一个或多个参数指定默认值</li><li>只能对排列在参数表后面的参数设定默认值</li><li>设定默认值以后，调用函数时可以省略默认值参数</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>引用概念：给对象取一个别名，对引用的操作就是对被它引用的对象的操作，即对原对象的操作</li><li>X&amp; r：r是“x类型的引用”，void&amp;是不被允许的<ul><li>&amp;r： 表示r所引用对象的地址</li></ul></li><li>引用必须做初始化，即一开始就得指向一个对象。</li><li>引用的值在初始化之后不可改变，总是指向初始化指向的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> xx =<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>&amp; rr = xx;<br>    rr++;<br>    <span class="hljs-type">int</span>* pp = &amp;rr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rr是xx的引用，对rr的操作即为对xx的操作，此时xx的值变为1</li></ul><h4 id="引用的主要用途"><a href="#引用的主要用途" class="headerlink" title="引用的主要用途"></a>引用的主要用途</h4><ul><li>作为函数的参数传递<ul><li>以实现在被调函数中改变调用函数的实参值</li></ul></li><li>作为函数的返回类型</li></ul><h4 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h4><p>1.这个问题是在重载一个矩阵加法的等号时发现的，实现加法的函数的返回值是函数内部的临时变量(在完成当前行操作时，会释放该临时变量.)，但是在等号赋值这一步，系统会报错。一直找不原因，然后突然加了个const编译通过了。我很不理解。后来搜到了这样的解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">matrix <span class="hljs-title">add_matrix</span><span class="hljs-params">(matrix&amp; m)</span></span>;<br>matrix&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> matrix&amp; m);<br>A3 = A1.<span class="hljs-built_in">add_matrix</span>(A2);<br></code></pre></td></tr></table></figure><ul><li>临时局部变量没有合法内存空间，不可以转为可变引用，因为可变引用需要合法的内存空间，但是常量引用可以接收这一类没有有效内存空间的值</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li>即两个以上的函数，具有相同的函数名，但是形参的个数和类型不同 </li><li>c++会自动进行最佳匹配，确定需要调用的函数</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="void类型指针"><a href="#void类型指针" class="headerlink" title="void类型指针"></a>void类型指针</h3><ul><li>void指针的值（地址）可以被赋值给任意类型的指针变量，但需要强制类型转换</li></ul><h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><p><code>const Type *ptr</code></p><ul><li>指向常量的指针，指针不是常量</li><li>不能通过指针来修改所指向对象的值，但指针本身可以改变，去指向另外的对象</li></ul><h3 id="指针类型的常量"><a href="#指针类型的常量" class="headerlink" title="指针类型的常量"></a>指针类型的常量</h3><p><code>Type * const ptr</code></p><ul><li>声明指针是常量，指针的值不能改变，即只能指向一个对象</li></ul><h2 id="c-源程序的构成"><a href="#c-源程序的构成" class="headerlink" title="c++源程序的构成"></a>c++源程序的构成</h2><ul><li>引入头文件<code>#include&lt;iostream&gt;</code> <code>#include&quot;stdafx.h&quot;</code></li><li>声明命名空间<code>using namespace std;</code></li><li>main函数</li></ul><h2 id="头文件-h-的使用建议"><a href="#头文件-h-的使用建议" class="headerlink" title="头文件(.h)的使用建议"></a>头文件(.h)的使用建议</h2><ul><li>将函数、类的声明在.h文件中，可以在多个cpp文件中引用</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_动态分配二维数组</title>
    <link href="/boker.github.io/2022/04/06/cpp/cpp-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/boker.github.io/2022/04/06/cpp/cpp-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>C++动态分配二维数组的方法以及以及注意事项</p><span id="more"></span><ul><li><p>动态分配空间</p><p>​    c++没有专门的动态分配二维数组的方法，但是我们知道的是，二维数组的实质其实就是一维的指针数组，这个数组的每个元素都是一个指针，这个指针及他后面的那一部分空间，就是二维数组中的一行。所以c++动态分配二维数组时，只要先分配出一个指针数组，然后再对这个指针数组中的每个指针分配空间即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>** p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>p[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">8</span>];<br>&#125;<br><span class="hljs-comment">//这就分配了一个10*8的二维数组</span><br></code></pre></td></tr></table></figure></li><li><p>释放空间</p><p>​    释放空间时，如果直接释放指针p，那么就相当于只释放了每行第一个元素，后面元素所占用的空间并没有释放。所以应当先释放指针数组中每个指针所占空间，再释放这个指针数组。并且，由于仅仅释放空间会使这些指针成为野指针，释放完的指针我们应当将其赋值为NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-keyword">delete</span> p[i];<br>    p[i] = null;<br>&#125;<br><span class="hljs-keyword">delete</span> []p;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++相关知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LoginApp</title>
    <link href="/boker.github.io/2022/04/03/LoginApp/"/>
    <url>/boker.github.io/2022/04/03/LoginApp/</url>
    
    <content type="html"><![CDATA[<p>从这里开始，制作一个可以实现登录功能的微信小程序</p><span id="more"></span><h2 id="一、前端设置"><a href="#一、前端设置" class="headerlink" title="一、前端设置"></a>一、前端设置</h2><p>1.在微信开发者工具中创建一个新项目，命名为LoginApp，</p><p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/1.png" alt="1"></p><p>新项目中没有任何文件，并且报出如上错误，接下来创建app.json</p><p>2.app.json中以字典的形式加入三个变量，pages，window，tabBar</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/2.png" alt="2" style="zoom: 67%;"><ul><li>pages：用来说明小程序都是由哪些页面组成的，列表中的值为对应页面的存储路径，框架会自动去该目录下找需要的四个文件</li><li>window：用与设置小程序的状态栏、导航条、标题、窗口背景色</li><li>tabbar：用来设置底部tab栏,list参数用于修改tab的属性</li></ul><p>3.找到login.wxml文件，并对登录页面进行设置</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/3.png" alt="3" style="zoom:80%;"><p>这里用到了数据绑定的知识，前端wxml页面中用两个大括号框起来的变量，可以与后端js中的数据双向绑定，绑定对象如下</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/4.png" alt="4" style="zoom:80%;"><p>4.找到login.js文件，完成绑定的两个输入事件</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/5.png" alt="5" style="zoom:80%;"><p>这里有两个注意事项：</p><ul><li>想要通过数据绑定改变前后端数据，只能通过在js方法中使用this.setData()函数，同时函数的参数应当为字典</li><li>在其他方法中访问data中的数据值，通过this.data.xxxx</li></ul><ol start="5"><li>调用wx.request接口,访问服务器</li></ol><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/6.png" alt="6" style="zoom: 80%;"><hr><h2 id="二、后端服务器设置"><a href="#二、后端服务器设置" class="headerlink" title="二、后端服务器设置"></a>二、后端服务器设置</h2><p>目前的想法是接收wx.request接口传入的用户名，密码，验证码等参数，与数据库中的用户名和密码对照，如果相同则完成登录</p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><h4 id="1-1-安装虚拟环境"><a href="#1-1-安装虚拟环境" class="headerlink" title="1.1 安装虚拟环境"></a>1.1 安装虚拟环境</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m venv ll_env<br></code></pre></td></tr></table></figure><h4 id="1-2-激活虚拟环境"><a href="#1-2-激活虚拟环境" class="headerlink" title="1.2 激活虚拟环境"></a>1.2 激活虚拟环境</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ll_env\Scripts\activate<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">deavtivate用于关闭虚拟环境</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-安装django-创建项目"><a href="#1-3-安装django-创建项目" class="headerlink" title="1.3 安装django,创建项目"></a>1.3 安装django,创建项目</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install django<br>django-admin startproject loginapp<br></code></pre></td></tr></table></figure><ul><li>此时安装的django仅在虚拟环境中可用</li></ul><h4 id="1-4-打开django服务器"><a href="#1-4-打开django服务器" class="headerlink" title="1.4 打开django服务器"></a>1.4 打开django服务器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py runserver <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li>可以在最后加上数字作为选择的端口</li><li>此时输入<a href="http://127.0.0.1：80/就可以访问django创建的服务器，这类似一个本地服务器，只能处理本地服务器发出的请求">http://127.0.0.1：80/就可以访问django创建的服务器，这类似一个本地服务器，只能处理本地服务器发出的请求</a></li></ul><h3 id="2-数据库创建"><a href="#2-数据库创建" class="headerlink" title="2.数据库创建"></a>2.数据库创建</h3><p>2.1 在命令行中执行如下命令，创建数据库</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> migrate<br></code></pre></td></tr></table></figure><p>这会在配置文件中生成一个数据库文件</p><p>2.2 定义数据库表</p><ul><li>首先创建一个应用目录，在里面存放项目需要的公共的表的定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py startapp common<br></code></pre></td></tr></table></figure><ul><li>models.py是存放数据库表的定义的，加入如下内容<ul><li>django.db.models里面有各种Filed对象，对应的是不同类型的字段</li></ul></li></ul><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/7.png" alt="7" style="zoom: 80%;"><p>2.3 创建数据库表</p><ul><li>在INSTALLED_APPS中加入如下声明，让django完成应用配置</li></ul><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;common.apps.CommonConfig</span>&#x27;<br></code></pre></td></tr></table></figure><ul><li>在根目录中执行命令</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> makemigration common<br><span class="hljs-keyword">python</span> manage.<span class="hljs-keyword">py</span> migrate<br></code></pre></td></tr></table></figure><p>此时真正完成了数据库表创建</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/8.png" alt="8" style="zoom:80%;"><ul><li>需要注意的点是，每次对models.py库表完成定义后，都要执行上方的命令行命令</li></ul><p>2.4 Admin管理数据</p><ul><li>这里我们使用的是SQlite数据库，这在简单的项目中具有简便，简单操作的特性<ul><li>打开SQlite，可以看到先前创建的数据库表</li></ul></li></ul><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/9.png" alt="9" style="zoom:67%;"><ul><li><p>django提供着一个管理员操作界面可以修改自己定义的model表数据</p><ul><li><p>首先，创建一个超级管理员账号，在根目录中执行如下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py createsuperuser<br></code></pre></td></tr></table></figure></li></ul><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/10.png" alt="10" style="zoom: 80%;"><ul><li><p>然后修改应用里面的管理员配置文件common/admin.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> adminfrom .models <span class="hljs-keyword">import</span> Customeradmin.site.register(Customer)<br></code></pre></td></tr></table></figure></li><li><p>此时访问<a href="http://127.0.0.1/admin/%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%E5%91%98%E6%93%8D%E4%BD%9C%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%90%91%E5%85%B6%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%94%A8%E6%88%B7">http://127.0.0.1/admin/即可访问管理员操作界面，向其中加入两个用户</a></p><p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/11.png" alt="11"></p></li></ul></li></ul><h3 id="3-实现登录"><a href="#3-实现登录" class="headerlink" title="3.实现登录"></a>3.实现登录</h3><p>当客户端发起http请求时，浏览器通过url在配置文件中找对应的文件，并执行相应的方法</p><p>3.1 设置url</p><ul><li><p>新建一个名为customer的应用程序，并在目录下创建urls.py文件，并存放访问url后执行的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> customer <span class="hljs-keyword">import</span> login<br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;customers&#x27;</span>, login.customer_login),<br>]<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在主目录的urls.py中进行如下设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include<br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    path(<span class="hljs-string">&#x27;login/&#x27;</span>, include(<span class="hljs-string">&#x27;customer.urls&#x27;</span>)),<br>]<br></code></pre></td></tr></table></figure></li><li><p>上述用到的include方法，会让浏览器在发现有login时，进入到customer.urls文件中查找</p></li></ul><p>3.2 实现登录逻辑</p><ul><li><p>这里首先通过自己的试验，得到了从前端传向后端的参数存放在http请求的请求体中，可以通过request.body获取数据</p></li><li><p>request.body中的数据以字典的形式存放</p></li></ul><p>3.2.1 数据处理</p><ul><li><p>通过request.body获得的数据为json格式，而json格式的数据在python看来，是字符串类型的变量，开始时没有注意到这个问题，所以在这里困了很久，会报错很多。这里选择的解决办法是：</p><ul><li>通过json.loads方法将json字符串转化为python字典，并且统一存入request的params属性中，访问params属性中的参数通过request.params[‘’]访问，就可以得到从客户端传入的json数据</li><li>json.loads方法需要import json包</li><li>获得了从客户端传入的数据，下一步就需要与数据库中的数据比较，可以通过下面的方法访问数据库中的数据</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">customer = Customer.objects.get(phonenumber=phoneNumber)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这里已知Customer是一个model类型的子类，</span><br><span class="hljs-string">    phoneNumber是字符串类型的数据，由客户端传入</span><br><span class="hljs-string">    .objects.get方法,匹配数据库中是否存在一个对象，满足该条件，如果满足条件，那么customer就是新创建的一个完全等同于数据库中该对象的实例，即可以通过该对象访问数据库中的数据</span><br><span class="hljs-string">    如果不满足条件，那么会报错。</span><br><span class="hljs-string">    所以一般情况下，这个语句会搭配try/except语句使用</span><br><span class="hljs-string">    如果想要不发生报错，也可以使用方法.object.filter，这个方法返回的是一个对象的列表</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>数据库还支持遍历所有表中数据来查找满足条件的数据，即通过过滤条件查询数据库内容，这里可以通过<a href="https://www.byhy.net/tut/webdev/django/05/%E6%9F%A5%E7%9C%8B%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%8C">https://www.byhy.net/tut/webdev/django/05/查看这部分内容，</a></p><p>  3.2.2 数据返回</p><ul><li><p>wx.request接口要求返回的数据为JSON格式，所以需要把python对象转换成JSON数据，json.dumps方法可以将python对象转化为JSON等效项。</p></li><li><p>返回数据的方法就我所看到的有两种方式，一种是使用HttpResponse返回，一种是使用JsonResponse返回，这两种返回数据的方法的区别目前我还没有搞明白，这里选择的使用httpResponse。使用方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;password is incorrect&#x27;</span>)<br><span class="hljs-comment"># data为一个python对象数据类型</span><br><span class="hljs-keyword">return</span> HttpResponse(json.dumps(data))<br></code></pre></td></tr></table></figure></li></ul><p>这样后端就完成了他的功能，此时在登录界面输入手机号、密码就可以进行前后端联系，可以看到data参数即为我们后端的返回值</p><img src="/boker.github.io/boker.github.io/2022/04/03/LoginApp/12.png" alt="12" style="zoom:80%;"><p>下方附上后端的全部代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">from</span> common.models <span class="hljs-keyword">import</span> Customer<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">customer_login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-comment"># 将请求参数统一放入request的params属性中，方便后续处理</span><br>        request.params = json.loads(request.body)<br>        <span class="hljs-comment"># 从http post请求中获取电话号、密码参数</span><br>        phoneNumber = request.params[<span class="hljs-string">&#x27;phonenumber&#x27;</span>]<br>        passWord = request.params[<span class="hljs-string">&#x27;password&#x27;</span>]<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 根据手机号从数据库中找到相应的客户记录</span><br>            customer = Customer.objects.get(phonenumber=phoneNumber)<br>            <span class="hljs-keyword">except</span> Customer.DoesNotExist:<br>                <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;this customer is not exist&#x27;</span>)<br>            <span class="hljs-keyword">if</span> customer.password == passWord:<br>                <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;login success&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;password is incorrect&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;this is not a post&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>微信小程序</tag>
      
      <tag>python后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_基础内容</title>
    <link href="/boker.github.io/2022/04/03/python/python_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/boker.github.io/2022/04/03/python/python_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>python相关的基础知识</p><span id="more"></span><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>当然如果要构造出更多的分支，可以使用<code>if...elif...else...</code>结构或者嵌套的<code>if...else...</code>结构，下面的代码演示了如何利用多分支结构实现分段函数求值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">score = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入成绩: &#x27;</span>))<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span>:<br>    grade = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">80</span>:<br>    grade = <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">70</span>:<br>    grade = <span class="hljs-string">&#x27;C&#x27;</span><br><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">60</span>:<br>    grade = <span class="hljs-string">&#x27;D&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    grade = <span class="hljs-string">&#x27;E&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;对应的等级是:&#x27;</span>, grade)<br></code></pre></td></tr></table></figure><p>每一个分支要有冒号，分支通过相同的缩进区别</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h4><p>如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用<code>for-in</code>循环，例如下面代码中计算1~100求和的结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>):<br>    <span class="hljs-built_in">sum</span> += x<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从1到100的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从1到100的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p><ul><li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li><li><code>range(1, 101)</code>：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。</li><li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。</li></ul><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环。<code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>则继续循环；表达式的值为<code>False</code>则结束循环。</p><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><code>and</code>、<code>or</code>和<code>not</code></p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></p><h4 id="整除符号"><a href="#整除符号" class="headerlink" title="整除符号"></a>整除符号</h4><p>//</p><h4 id="输入输出的一些方法"><a href="#输入输出的一些方法" class="headerlink" title="输入输出的一些方法"></a>输入输出的一些方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">使用input()函数获取键盘输入(字符串)</span><br><span class="hljs-string">使用int()函数将输入的字符串转换成整数</span><br><span class="hljs-string">使用print()函数输出带占位符的字符串</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;a = &#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d + %d = %d&#x27;</span> % (a, b, a + b))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;f:<span class="hljs-number">.1</span>f&#125;</span>华氏度 = <span class="hljs-subst">&#123;c:<span class="hljs-number">.1</span>f&#125;</span>摄氏度&#x27;</span>)<br></code></pre></td></tr></table></figure><p>由于print函数会自动打出换行，所以如果不需要换行，在输出后多打一个end=’’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">row = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入行数: &#x27;</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过<code>return</code>关键字来返回一个值，这相当于数学上说的函数的因变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>（参数列表）:<br>    函数体<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a=<span class="hljs-string">&quot;Runoob&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li><li><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 指向的是同一个对象</span><br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 一个新对象</span><br><br>a = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))<br>change(a)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1706410993968</span><br><span class="hljs-string">1706410993968</span><br><span class="hljs-string">1706410994256</span><br><span class="hljs-string">1</span><br><span class="hljs-string">1706410993968</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">对于不可变类型（对象）<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">变量仅仅是对一个对象的引用，可以类似的看作是一个指针，</span><br><span class="hljs-string">它可以指向不同的对象，更改变量只是让这个指针指向不同的对象，并且不同的对象有不同的地址</span><br><span class="hljs-string">可以看到，传递参数时，传递的只是a的值，并且在函数外部，该变量的值不会因为函数内部而改变</span><br><span class="hljs-string">由于没有影响到这个对象本身，即此时还指向的是同一个对象，</span><br><span class="hljs-string">所以他们对应的是同一个地址，此时修改a的值，则会生成一个新的对象被指向</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>对于可变类型（对象）<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">在函数内部改变变量会影响到函数外部的值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-string">&#x27;&#x27;&#x27;打印任何传入的字符串&#x27;&#x27;&#x27;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用 printme 函数，不加参数会报错</span><br>printme(<span class="hljs-string">&quot;im good&quot;</span>)<br>printme()<br></code></pre></td></tr></table></figure><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> name, age </span>):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( age=<span class="hljs-number">50</span>, name=<span class="hljs-string">&quot;runoob&quot;</span> )<br></code></pre></td></tr></table></figure><p>可以看到这里并不需要参数调用顺序与参数声明顺序一致</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> name, age = <span class="hljs-number">35</span> </span>):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>   <span class="hljs-keyword">return</span><br><br>printinfo( name=<span class="hljs-string">&quot;runoob&quot;</span> )<br></code></pre></td></tr></table></figure><p>此时函数中默认其参数为age=35</p><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p><p>第一个参数为普通的参数，第二个参数为不定长参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params">[formal_args,] *var_args_tuple </span>):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, *vartuple </span>):<br>    <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>    <span class="hljs-built_in">print</span> (arg1)<br>    <span class="hljs-built_in">print</span> (vartuple)<br>    <span class="hljs-comment"># 调用printinfo函数</span><br>    printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数，默认将后几个参数存放到一个元组里面。不定长参数可以不传入</p><p>还有一种就是参数带两个星号 ******基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params">[formal_args,] **var_args_dict </span>):<br>    <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>    function_suite<br>    <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, **vardict </span>):<br>    <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>    <span class="hljs-built_in">print</span> (arg1)<br>    <span class="hljs-built_in">print</span> (vardict)<br>    <span class="hljs-comment"># 调用printinfo</span><br>    函数printinfo(<span class="hljs-number">1</span>, a=<span class="hljs-number">2</span>,b=<span class="hljs-number">3</span>)<br>    <span class="hljs-string">&#x27;&#x27;&#x27;输出: 1&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125;&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):<br>    <span class="hljs-keyword">return</span> a+b+c<br></code></pre></td></tr></table></figure><p>如果单独出现星号 ***** 后的参数必须用关键字传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="解决不同模块命名重复的方法"><a href="#解决不同模块命名重复的方法" class="headerlink" title="解决不同模块命名重复的方法"></a>解决不同模块命名重复的方法</h3><h4 id="1-用as取别名"><a href="#1-用as取别名" class="headerlink" title="1.用as取别名"></a>1.用as取别名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> untils.foo <span class="hljs-keyword">import</span> say_hello <span class="hljs-keyword">as</span> s1<br><span class="hljs-keyword">from</span> untils.bar <span class="hljs-keyword">import</span> say_hello <span class="hljs-keyword">as</span> s2<br></code></pre></td></tr></table></figure><h4 id="2-使用完全限定名"><a href="#2-使用完全限定名" class="headerlink" title="2.使用完全限定名"></a>2.使用完全限定名</h4><p>包名.模块名.函数名（包名可以省略）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> untils <span class="hljs-keyword">import</span> foo<br><span class="hljs-keyword">from</span> untils <span class="hljs-keyword">import</span> barfoo.say_hello()<br>bar.say_hello()<br>untils.foo.say_hello()<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型和运算"><a href="#基本数据类型和运算" class="headerlink" title="基本数据类型和运算"></a>基本数据类型和运算</h3><p>1.Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>2.在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p>3.Python允许你同时为多个变量赋值</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a=b=c=<span class="hljs-number">1</span>；<br>a，b，c=<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，“lululu”；<br></code></pre></td></tr></table></figure><p>4.一个变量可以通过赋值指向不同类型的对象</p><p>5.数值的除法包含两个运算符：**/** 返回一个浮点数，**//** 返回一个整数</p><p>6.在混合计算时，Python会把整型转换成为浮点数。</p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>1.Python3 中有六个标准的数据类型：</p><p>Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典）</p><p>2.Python3 的六个标准数据类型中：</p><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</p><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）</p><h4 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h4><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><p>1.int (整数),  只有一种整数类型 int，表示为长整型</p><p>2.bool (布尔), 如 True。</p><p>3.float (浮点数), 如 1.23、3E-2</p><p>4.complex (复数), 如 1 + 2j、 1.1 + 2.2j</p><h4 id="字符串-String-类型"><a href="#字符串-String-类型" class="headerlink" title="字符串(String)类型"></a>字符串(String)类型</h4><p>1.python中单引号和双引号使用完全相同。</p><p>2.使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</p><p>3.转义符 ,反斜杠可以用来转义，使用r可以让反斜杠不发生转义，也可以用ascii码和unicode字符编码表示字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;\141\142\143\x61\x62\x63&#x27;</span><br><span class="hljs-comment">#abcabc</span><br>s2 = <span class="hljs-string">&#x27;\u9a86\u660a&#x27;</span><br><span class="hljs-comment">#骆昊</span><br><span class="hljs-string">r&quot;this is a line with \n&quot;</span><br><span class="hljs-comment">#\n会显示，并不是换行。</span><br></code></pre></td></tr></table></figure><p>4.按字面意义级联字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;this &quot;</span>,<span class="hljs-string">&quot;is &quot;</span>,<span class="hljs-string">&quot;string&quot;</span>)<br><span class="hljs-comment">#this is string。</span><br></code></pre></td></tr></table></figure><p>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello &#x27;</span> * <span class="hljs-number">3</span><br>s2 = <span class="hljs-string">&#x27;world&#x27;</span><br>s1 += s2<br><span class="hljs-built_in">print</span>(s1) <br><span class="hljs-comment"># hello hello hello world</span><br><br></code></pre></td></tr></table></figure><p>5.可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串（成员运算）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;ll&#x27;</span> <span class="hljs-keyword">in</span> s1 <span class="hljs-comment"># True</span><br><span class="hljs-string">&#x27;good&#x27;</span> <span class="hljs-keyword">in</span> s1 <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>6.Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p><p>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</p><p>尾下标指输出到该位置停止，并不输出该字符，输出的总长度为尾下标减去头下标    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str2[<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(str2[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(str2[-<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-comment">#输出倒数第三个到最后一个字符</span><br></code></pre></td></tr></table></figure><p>7.Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span> * <span class="hljs-number">2</span>)      <span class="hljs-comment"># 输出字符串两次，也可以写成 print (2 * str)</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;TEST&quot;</span>) <span class="hljs-comment"># 连接字符串</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])     <span class="hljs-comment"># 输出从第三个开始到第五个的字符</span><br></code></pre></td></tr></table></figure><p>8.Python中的字符串不能改变。</p><h4 id="List（列表）类型"><a href="#List（列表）类型" class="headerlink" title="List（列表）类型"></a>List（列表）类型</h4><p>1,列表类似于c语言中的数组，但其优点在于<strong>列表中的元素类型可以不同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</strong></p><p>2,列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表,多个列表之间可以用+相连接</p><p>3,和字符串一样，列表同样可以被索引和截取，列表被<strong>截取后返回一个包含所需元素的新列表。</strong></p><p>4,列表截取的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">变量[头下标:尾下标：步长]<br></code></pre></td></tr></table></figure><!--后两个可以省略，但是省略时要保留前面的冒号--><p>当步长为负数时，表示逆向读取。可以用于翻转字符串</p><p>5,列表的初始化实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [ <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">786</span> , <span class="hljs-number">2.23</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-number">70.2</span> ]<br>tinylist = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>]<br>list2 = [<span class="hljs-string">&#x27;hello&#x27;</span>] * <span class="hljs-number">3</span><br><span class="hljs-comment">#[&#x27;hello&#x27;,&#x27;hello&#x27;,&#x27;hello&#x27;]</span><br></code></pre></td></tr></table></figure><p>6,其输出与字符串类似，输出的结果仍然以一个列表的方式输出，<strong>与字符串不同的是，列表中的元素是可以改变的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = []   <span class="hljs-comment"># 将对应的元素值设置为 []</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>7,遍历列表元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过循环用下标遍历列表元素</span><br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list1)):<br>    <span class="hljs-built_in">print</span>(list1[index])<br><span class="hljs-comment"># 通过for循环遍历列表元素</span><br><span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> list1:<br>    <span class="hljs-built_in">print</span>(elem)<br><span class="hljs-comment"># 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值</span><br><span class="hljs-keyword">for</span> index, elem <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list1):<br>    <span class="hljs-built_in">print</span>(index, elem)<br></code></pre></td></tr></table></figure><h4 id="Tuple（元组）类型"><a href="#Tuple（元组）类型" class="headerlink" title="Tuple（元组）类型"></a>Tuple（元组）类型</h4><p>元组（tuple）与列表类似，<strong>不同之处在于元组的元素不能修改</strong>。元组<strong>写在小括号 ()</strong> 里，元素之间用逗号隔开，元组中的元素类型也可以不相同：</p><p>1.元组的初始化及输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span> = ( <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">786</span> , <span class="hljs-number">2.23</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-number">70.2</span>  )<br><span class="hljs-built_in">print</span>(tulpe[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>虽然元组的元素不能改变，但是能包含可变的对象，如list列表。</p><p>2.构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tup1 = ()    <span class="hljs-comment"># 空元组</span><br>tup2 = (<span class="hljs-number">20</span>,) <span class="hljs-comment"># 一个元素，需要在元素后添加逗号</span><br></code></pre></td></tr></table></figure><p>3.string、list 和 tuple 都属于 sequence（序列）。</p><p>4.元组的操作与列表基本相同。</p><h4 id="Set（集合）类型"><a href="#Set（集合）类型" class="headerlink" title="Set（集合）类型"></a>Set（集合）类型</h4><p>1.集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sites = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>, <span class="hljs-string">&#x27;Zhihu&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>&#125;<br><span class="hljs-built_in">set</span>(value)<br></code></pre></td></tr></table></figure><p>2.功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">a.输出集合，重复的元素被自动去掉<br><span class="hljs-built_in">print</span>(sites)   <br><br>b.成员测试<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Runoob&#x27;</span> <span class="hljs-keyword">in</span> sites :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob 在集合中&#x27;</span>)<br><br>c.<span class="hljs-built_in">set</span>可以进行集合运算<br>a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<br><span class="hljs-built_in">print</span>(a - b)     <span class="hljs-comment"># a 和 b 的差集</span><br><span class="hljs-built_in">print</span>(a | b)     <span class="hljs-comment"># a 和 b 的并集</span><br><span class="hljs-built_in">print</span>(a &amp; b)     <span class="hljs-comment"># a 和 b 的交集</span><br><span class="hljs-built_in">print</span>(a ^ b)     <span class="hljs-comment"># a 和 b 中不同时存在的元素</span><br></code></pre></td></tr></table></figure><h4 id="Dictionary（字典）类型"><a href="#Dictionary（字典）类型" class="headerlink" title="Dictionary（字典）类型"></a>Dictionary（字典）类型</h4><p>1.列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>2.字典是一种映射类型，类似于函数，一个自变量对应一个因变量，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>3.键(key)必须使用不可变类型，在同一个字典中，键(key)必须是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;&#125;    <span class="hljs-comment">#创建一个新的空字典</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&quot;1 - 菜鸟教程&quot;</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>]     = <span class="hljs-string">&quot;2 - 菜鸟工具&quot;</span><br><br>tinydict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;runoob&#x27;</span>,<span class="hljs-string">&#x27;code&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;site&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>])       <span class="hljs-comment"># 输出键为 &#x27;one&#x27; 的值</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>])           <span class="hljs-comment"># 输出键为 2 的值</span><br><span class="hljs-built_in">print</span> (tinydict)          <span class="hljs-comment"># 输出完整的字典</span><br><span class="hljs-built_in">print</span> (tinydict.keys())   <span class="hljs-comment"># 输出所有键</span><br><span class="hljs-built_in">print</span> (tinydict.values()) <span class="hljs-comment"># 输出所有值</span><br></code></pre></td></tr></table></figure><p>4.构造函数 dict() 可以直接从键值对序列中构建字典如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-number">3</span>)])<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">6</span>: <span class="hljs-number">36</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(Runoob=<span class="hljs-number">1</span>, Google=<span class="hljs-number">2</span>, Taobao=<span class="hljs-number">3</span>)<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>此文记录了我第一次通过hexo框架搭建博客的一些心得，介绍了Hexo博客的搭建方法和一些使用方法，会持续在这里更新一些新学到的hexo使用方法。</p><span id="more"></span><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>安装node.js,Git</p><p><a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi">https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi</a></p><p><a href="https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.3/Git-2.11.0.3-64-bit.exe">https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.3/Git-2.11.0.3-64-bit.exe</a></p><ul><li><p>安装完成后，需要将git,node.js,npm都设置为环境变量，将三者的绝对路径复制到环境变量的设置中，具体操作可以百度。</p></li><li><p>设置完环境变量可以通过命令行中进行如下的输入来判断是否安装成功以及安装的版本信息。</p></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br>git --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>​    在这里踩了很大的坑，一开始搜了很多教程，跟着网上的这些教程做的过程中报了很多错，可能与我git和node.js以前下载过，后来重新下载位置改变有关，在这里就卡了很久，后来发现在hexo的官方网站上有一些一键部署指令，很简洁并且一次就成功了。只需要在命令行中输入如下指令即可。</p><ul><li><p>初始化hexo基础配置文件</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure></li><li><p>初始化hexo，并且建立在blog文件夹中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> blog<br></code></pre></td></tr></table></figure></li><li><p>进入到blog文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<br></code></pre></td></tr></table></figure></li><li><p>配置node</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li><li><p>加载hexo基础html、css、js等文件</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  <span class="hljs-comment">//hexo g</span><br></code></pre></td></tr></table></figure></li><li><p>开启本地服务器</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li></ul><p>​    输入完最后一条指令之后，hexo会开启一个本地服务器，并且会给你一个本地服务器的url，将这个url复制到你的浏览器中，可以看到hexo默认配置的静态网页，这时你的博客就可以算是在本地搭建完啦。</p><h3 id="hexo文件"><a href="#hexo文件" class="headerlink" title="hexo文件"></a>hexo文件</h3><p><img src="/boker.github.io/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.png"></p><p>主要会用到以下三个文件</p><ul><li>config.yml<ul><li>用于修改网站配置，配置设定，网站的标题，网址等。</li><li>可以搜索官方文档具体使用。</li></ul></li><li>source 资源<ul><li>用于存放原始资源的地方，自己上传的图片，markdown文章等。</li><li>其中_posts文件夹中存放的是那些要上传到网站上的资源。</li></ul></li><li>themes 主题<ul><li>用来存放主题的文件夹。</li><li>会根据主题解析source文件夹中的档案来生成静态页面。预设主题为landscape。</li></ul></li></ul><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>​    在hexo官网中你可以找到很多博客主题，我选择的是fluid主题。点击图片可以进行预览，点击标题就会进入下载界面，将下载下来的压缩包解压到先前提到的themes主题文件夹中，一般下载的主题都会有专门的用户文档描述使用方法，可以在主题存放的github仓库的readme 文档中找到，解压下来的文件夹需要重命名为主题名。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>设置主题是在hexo根目录下的config.yml文件中，修改themes属性。例如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid<br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>​    你可以自主修改主题中的很多配置，在主题对应的用户文档中都会有详细的使用说明，修改主题主要是在你主题文件夹下的config.yml文件里。需要注意的是，该config.yml文件与根目录中的config.yml文件是不同的，这个文件是用来配置主题相关属性的，对于二者重叠的属性修改，主题文件夹下的config.yml具有更高的优先级。</p><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><h4 id="建立GitHub仓库"><a href="#建立GitHub仓库" class="headerlink" title="建立GitHub仓库"></a>建立GitHub仓库</h4><p>Step1.注册GitHub账号并登录</p><ul><li>需要注意的是，GitHub作为国外网站，在国内登录时会出现加载很慢或者直接无法进入网站的情况。</li><li>我是通过挂梯子解决这个问题的，网上可以搜到一些教程修改本地设置也可以成功登录，我试过没成功，就再没试过了。</li></ul><p>Step2.点击New新建一个github仓库</p><p><img src="/boker.github.io/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2.png" alt="2"></p><p>step3.进入到你的github仓库中，点击settings-&gt;pages，在Source里将branch设置为main，然后点击save，可以看到上方的绿色框中会生成一个url网址，这就是你未来的博客网址了。</p><p><img src="/boker.github.io/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3.png" alt="3"></p><h4 id="将内容上传到GitHub"><a href="#将内容上传到GitHub" class="headerlink" title="将内容上传到GitHub"></a>将内容上传到GitHub</h4><p>Step1.安装Git相关套件</p><p>这一步需要回到hexo根目录中，在终端命令行中输入以下命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>Step2.修改_config.yml文件的deployment设置</p><p>需要主要的是这里的_config.yml指的是根目录中的文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repository:</span> git@github.com:username/username.github.io.git<br><span class="hljs-symbol">branch:</span> main<br></code></pre></td></tr></table></figure><p>​    这一步可以说是我踩过最大的坑了，这里的repository使用的url应当是ssh形式的，如下图所示，并且，这里的url不能直接复制，使用github的ssh需要本地有对应的ssh密钥，应当先设置一个自己的ssh密钥，然后才能上传自己的内容到github中。</p><p><img src="/boker.github.io/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4.png" alt="4"></p><ul><li><p>github的ssh密钥的设置</p><ul><li><p>在命令行中输入如下指令，会在你的电脑本地生成一个rsa文件，这个rsa文件用于生成自己的ssh密钥.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>你只需要把里面的邮箱地址换成你自己的邮箱地址即可.</p></li><li><p>然后共有三次输入，第一次为你rsa文件的名字，二三次是密码的设置.</p></li><li><p>然后在C-user-.ssh文件夹中，可以找到一个rea.pub文件,打开文件复制里面的内容.</p></li><li><p>右上角点击头像-&gt;settings-&gt;SSH and GPG key-&gt;new key生成一个自己的ssh密钥.</p><p><img src="/boker.github.io/boker.github.io/2022/04/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5.png"></p></li></ul></li></ul><p>Step3.输入部署指令</p><p>这三条指令在你每次修改完博客要重新上传文件时，都需要使用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean  <span class="hljs-comment">//hexo cl</span><br>hexo <span class="hljs-keyword">generate</span>  <span class="hljs-comment">// hexo g</span><br>hexo deploy  <span class="hljs-comment">// hexo d</span><br></code></pre></td></tr></table></figure><p>这样,你的hexo博客部署就已经完成啦,将github仓库中生成的你的url输入浏览器中,你就可以看到自己的博客啦!</p>]]></content>
    
    
    <categories>
      
      <category>Hexo博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_library</title>
    <link href="/boker.github.io/2022/04/01/python/python_library/"/>
    <url>/boker.github.io/2022/04/01/python/python_library/</url>
    
    <content type="html"><![CDATA[<p>python库函数中与变量相关的方法以及python的一些小知识点</p><span id="more"></span><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="更改vscode输出位置"><a href="#更改vscode输出位置" class="headerlink" title="更改vscode输出位置"></a>更改vscode输出位置</h2><p>console属性是integratedTerminal时，会把结果输出到终端，是internalConsole时会输出到调试控制台。</p><h2 id="查询变量类型"><a href="#查询变量类型" class="headerlink" title="查询变量类型"></a>查询变量类型</h2><p>type() 函数可以用来查询变量所指的对象类型，此外还可以用 isinstance 来判断</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">int</span>)<br>=<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><p>　type()不会认为子类是一种父类类型。</p><p>　isinstance()会认为子类是一种父类类型。</p><p>　例如，bool为int的子类</p><h2 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h2><p>使用del语句删除一些对象引用,也可以删除数组的片段</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">del</span> car（删除对象）<br><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[2:4]</span>（删除数组的第三个到第五个元素）<br></code></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>1.Python中单行注释以 # 开头,多行注释可以用多个 # 号，还有 ‘’’ 和 “””</p><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数</p><h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 </p><p>空行</p><p>1.函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>2.空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>1.Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割</p><p>多个语句构成代码组</p><p>1.缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>2.像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>3.我们将首行及后面的代码组称为一个子句(clause)。</p><h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””：</p><h2 id="import-from…import"><a href="#import-from…import" class="headerlink" title="import,from…import"></a>import,from…import</h2><p>1.在 python 用 import 或者 from…import 来导入相应的模块。</p><p>2.将整个模块(somemodule)导入，格式为： import somemodule</p><p>3.从某个模块中导入某个函数,格式为： from somemodule import somefunction</p><p>4.从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p><p>5.将某个模块中的全部函数导入，格式为： from somemodule import *</p><h2 id="字符串相关方法"><a href="#字符串相关方法" class="headerlink" title="字符串相关方法"></a>字符串相关方法</h2><p>str1 = ‘hello, world!’</p><h3 id="1-计算字符串的长度"><a href="#1-计算字符串的长度" class="headerlink" title="1.计算字符串的长度"></a>1.计算字符串的长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(str1)) <span class="hljs-comment"># 13</span><br></code></pre></td></tr></table></figure><h3 id="2-获得字符串首字母大写"><a href="#2-获得字符串首字母大写" class="headerlink" title="2.获得字符串首字母大写"></a>2.获得字符串首字母大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.capitalize()) <span class="hljs-comment"># Hello, world!</span><br></code></pre></td></tr></table></figure><h3 id="3-获得字符串每个单词首字母大写"><a href="#3-获得字符串每个单词首字母大写" class="headerlink" title="3.获得字符串每个单词首字母大写"></a>3.获得字符串每个单词首字母大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.title()) <span class="hljs-comment"># Hello, World!</span><br></code></pre></td></tr></table></figure><h3 id="4-字符串全部大写"><a href="#4-字符串全部大写" class="headerlink" title="4.字符串全部大写"></a>4.字符串全部大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.upper()) <span class="hljs-comment"># HELLO, WORLD!</span><br></code></pre></td></tr></table></figure><h3 id="5-查找子串所在位置"><a href="#5-查找子串所在位置" class="headerlink" title="5.查找子串所在位置"></a>5.查找子串所在位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#查找失败返回-1</span><br><span class="hljs-built_in">print</span>(str1.find(<span class="hljs-string">&#x27;or&#x27;</span>)) <span class="hljs-comment"># 8</span><br><span class="hljs-built_in">print</span>(str1.find(<span class="hljs-string">&#x27;shit&#x27;</span>)) <span class="hljs-comment"># -1</span><br><span class="hljs-comment"># 与find类似但找不到子串时会引发异常</span><br><span class="hljs-built_in">print</span>(str1.index(<span class="hljs-string">&#x27;or&#x27;</span>))<br><span class="hljs-built_in">print</span>(str1.index(<span class="hljs-string">&#x27;shit&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="6-检查字符串是否以指定的字符串开头"><a href="#6-检查字符串是否以指定的字符串开头" class="headerlink" title="6.检查字符串是否以指定的字符串开头"></a>6.检查字符串是否以指定的字符串开头</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.startswith(<span class="hljs-string">&#x27;He&#x27;</span>)) <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(str1.startswith(<span class="hljs-string">&#x27;hel&#x27;</span>)) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h3 id="7-检查字符串是否以指定的字符串结尾"><a href="#7-检查字符串是否以指定的字符串结尾" class="headerlink" title="7.检查字符串是否以指定的字符串结尾"></a>7.检查字符串是否以指定的字符串结尾</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.endswith(<span class="hljs-string">&#x27;!&#x27;</span>)) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h3 id="8-将字符串以指定的宽度居中并在两侧填充指定的字符"><a href="#8-将字符串以指定的宽度居中并在两侧填充指定的字符" class="headerlink" title="8.将字符串以指定的宽度居中并在两侧填充指定的字符"></a>8.将字符串以指定的宽度居中并在两侧填充指定的字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.center(<span class="hljs-number">50</span>, <span class="hljs-string">&#x27;*&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="9-将字符串以指定的宽度靠右放置左侧填充指定的字符"><a href="#9-将字符串以指定的宽度靠右放置左侧填充指定的字符" class="headerlink" title="9.将字符串以指定的宽度靠右放置左侧填充指定的字符"></a>9.将字符串以指定的宽度靠右放置左侧填充指定的字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str1.rjust(<span class="hljs-number">50</span>, <span class="hljs-string">&#x27; &#x27;</span>))<br></code></pre></td></tr></table></figure><p>str2 = ‘abc123456’</p><h3 id="10-检查字符串是否由数字构成"><a href="#10-检查字符串是否由数字构成" class="headerlink" title="10.检查字符串是否由数字构成"></a>10.检查字符串是否由数字构成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str2.isdigit())  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h3 id="11-检查字符串是否以字母构成"><a href="#11-检查字符串是否以字母构成" class="headerlink" title="11.检查字符串是否以字母构成"></a>11.检查字符串是否以字母构成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str2.isalpha())  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h3 id="12-检查字符串是否以数字和字母构成"><a href="#12-检查字符串是否以数字和字母构成" class="headerlink" title="12.检查字符串是否以数字和字母构成"></a>12.检查字符串是否以数字和字母构成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(str2.isalnum())  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h3 id="13-获得字符串修剪左右两侧空格之后的拷贝"><a href="#13-获得字符串修剪左右两侧空格之后的拷贝" class="headerlink" title="13.获得字符串修剪左右两侧空格之后的拷贝"></a>13.获得字符串修剪左右两侧空格之后的拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">str3 = <span class="hljs-string">&#x27;  jackfrued@126.com &#x27;</span><br><span class="hljs-built_in">print</span>(str3)<br><span class="hljs-built_in">print</span>(str3.strip())<br><span class="hljs-comment">#strip,lstrip,rstrip#删除两侧，删除左侧，删除右侧</span><br></code></pre></td></tr></table></figure><h3 id="14-在字符串中使用变量"><a href="#14-在字符串中使用变量" class="headerlink" title="14.在字符串中使用变量"></a>14.在字符串中使用变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;方法一：f字符串&#x27;&#x27;&#x27;</span><br>first_name=<span class="hljs-string">&quot;ada&quot;</span><br>last_name=<span class="hljs-string">&quot;lovelace&quot;</span><br>full_name=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;first_name&#125;</span><span class="hljs-subst">&#123;lastname&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(full_name)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello,<span class="hljs-subst">&#123;full_name&#125;</span>&quot;</span>)<span class="hljs-comment">#ada lovelace</span><br><span class="hljs-string">&#x27;&#x27;&#x27;方法二：format方法&#x27;&#x27;&#x27;</span><br>full_name=<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>&#123;first_name,last_name&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a, b, a * b))<br></code></pre></td></tr></table></figure><h2 id="列表相关方法"><a href="#列表相关方法" class="headerlink" title="列表相关方法"></a>列表相关方法</h2><p>list1 = [1, 3, 5, 7, 100]</p><h3 id="1-计算列表长度"><a href="#1-计算列表长度" class="headerlink" title="1.计算列表长度"></a>1.计算列表长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(list1) <span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h3 id="2-在列表末尾添加元素"><a href="#2-在列表末尾添加元素" class="headerlink" title="2.在列表末尾添加元素"></a>2.在列表末尾添加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">list1.append(<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><h3 id="3-在对应下标处添加元素"><a href="#3-在对应下标处添加元素" class="headerlink" title="3.在对应下标处添加元素"></a>3.在对应下标处添加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1.insert(<span class="hljs-number">1</span>, <span class="hljs-number">400</span>)<br><span class="hljs-comment"># list1[1]=400</span><br></code></pre></td></tr></table></figure><h3 id="4-合并两个列表"><a href="#4-合并两个列表" class="headerlink" title="4.合并两个列表"></a>4.合并两个列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">list1.extend([<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>])<br>list1 += [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>]<br><span class="hljs-comment">#二者等效，都是将两个列表合并，添加的元素放在列表的末尾</span><br></code></pre></td></tr></table></figure><h3 id="5-删除列表中的元素"><a href="#5-删除列表中的元素" class="headerlink" title="5.删除列表中的元素"></a>5.删除列表中的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;判断元素是否存在存在则删除该元素&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-number">3</span> <span class="hljs-keyword">in</span> list1:<br>    list1.remove(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#[1, 5, 7, 100]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;从指定的位置删除元素&#x27;&#x27;&#x27;</span><br>list1.pop(<span class="hljs-number">0</span>)<br>list1.pop(<span class="hljs-built_in">len</span>(list1) - <span class="hljs-number">1</span>)<br><span class="hljs-comment">#[3, 5, 7]</span><br></code></pre></td></tr></table></figure><h3 id="6-清空列表"><a href="#6-清空列表" class="headerlink" title="6.清空列表"></a>6.清空列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">list1.clear() <span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure><h3 id="7-对列表排序"><a href="#7-对列表排序" class="headerlink" title="7.对列表排序"></a>7.对列表排序</h3><p>list1 = [‘orange’, ‘apple’, ‘zoo’, ‘internationalization’, ‘blueberry’]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;sorted函数排序后不会对原列表产生影响，list1中的顺序不变&#x27;&#x27;&#x27;</span><br>list2 = <span class="hljs-built_in">sorted</span>(list1)<br><span class="hljs-comment">#按字母表顺序对列表排序</span><br>list3 = <span class="hljs-built_in">sorted</span>(list1, reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#字母表逆序对列表排序</span><br>list4 = <span class="hljs-built_in">sorted</span>(list1, key=<span class="hljs-built_in">len</span>)<br><span class="hljs-comment">#通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span><br><span class="hljs-string">&#x27;&#x27;&#x27;sort函数会直接在列表对象上进行排序&#x27;&#x27;&#x27;</span><br>list1.sort(reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="集合相关方法"><a href="#集合相关方法" class="headerlink" title="集合相关方法"></a>集合相关方法</h2><h3 id="1-向集合中添加元素"><a href="#1-向集合中添加元素" class="headerlink" title="1.向集合中添加元素"></a>1.向集合中添加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;<br>set1.add(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(set1)<br><span class="hljs-comment">#&#123;1,2,3,4&#125;</span><br>set1.update([<span class="hljs-number">12</span>,<span class="hljs-number">13</span>])<br><span class="hljs-comment">#&#123;1,2,3,4,12,13&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-从集合中删除元素"><a href="#2-从集合中删除元素" class="headerlink" title="2.从集合中删除元素"></a>2.从集合中删除元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">set1.remove(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#&#123;1,2,3,12,13&#125;</span><br><span class="hljs-comment">#删除指定位置上的元素</span><br>set1.pop()<br><span class="hljs-comment">#&#123;2,3,4,12,13&#125;</span><br><span class="hljs-comment">#删除第一个元素</span><br></code></pre></td></tr></table></figure><h2 id="字典相关方法"><a href="#字典相关方法" class="headerlink" title="字典相关方法"></a>字典相关方法</h2><h3 id="1-删除字典中的元素"><a href="#1-删除字典中的元素" class="headerlink" title="1.删除字典中的元素"></a>1.删除字典中的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">scores = &#123;<span class="hljs-string">&#x27;骆昊&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;白元芳&#x27;</span>: <span class="hljs-number">78</span>, <span class="hljs-string">&#x27;狄仁杰&#x27;</span>: <span class="hljs-number">82</span>&#125;<br><span class="hljs-built_in">print</span>(scores.pop(<span class="hljs-string">&#x27;骆昊&#x27;</span>, <span class="hljs-number">100</span>))<span class="hljs-comment">#95</span><br><span class="hljs-comment">#删除对应的键值对</span><br><span class="hljs-built_in">print</span>(scores.popitem())<br><span class="hljs-built_in">print</span>(scores)<br><span class="hljs-comment">#(&#x27;狄仁杰&#x27;, 82)</span><br><span class="hljs-comment">#&#123;&#x27;骆昊&#x27;: 95, &#x27;白元芳&#x27;: 78&#125;</span><br><span class="hljs-comment">#删除最后一对键值对</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
